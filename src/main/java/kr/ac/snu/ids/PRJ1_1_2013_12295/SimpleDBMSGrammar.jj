options
{
  static = true;
  DEBUG_PARSER = false;
  IGNORE_CASE = true;
}

PARSER_BEGIN(SimpleDBMSParser)
package kr.ac.snu.ids.PRJ1_1_2013_12295;

public class SimpleDBMSParser
{
  public static final String PROMPT = "DB_2013-12295> ";

  enum QueryType
  {
    SYNTAX_ERROR,
    CREATE_TABLE,
    DROP_TABLE,
    DESC,
    SHOW_TABLES,
    SELECT,
    INSERT,
    DELETE,
  }

  public static void main(String args[]) throws ParseException
  {
    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);
    System.out.print(PROMPT);

    while (true)
    {
      try
      {
        parser.command();
      }
      catch (Exception e)
      {
        printMessage(QueryType.SYNTAX_ERROR);
        SimpleDBMSParser.ReInit(System.in);
      }
    }
  }

  public static void printMessage(QueryType t)
  {
    switch(t)
    {
      case SYNTAX_ERROR:
        System.out.println("Syntax error");
        break;
      case CREATE_TABLE:
        System.out.println("\'CREATE TABLE\' requested");
        break;
      case DROP_TABLE:
        System.out.println("\'DROP TABLE\' requested");
        break;
      case DESC:
        System.out.println("\'DESC\' requested");
        break;
      case SHOW_TABLES:
        System.out.println("\'SHOW TABLES\' requested");
        break;
      case SELECT:
        System.out.println("\'SELECT\' requested");
        break;
      case INSERT:
        System.out.println("\'INSERT\' requested");
        break;
      case DELETE:
        System.out.println("\'DELETE\' requested");
        break;
      default:
        System.out.println("unknown message accepted");
        break;
    }
    System.out.print(PROMPT);
  }
}

PARSER_END(SimpleDBMSParser)

SKIP : { " " | "\r" | "\t" | "\n" }

TOKEN : /* Keywords */
{
  < EXIT : "exit" >
| < INT : "int" >
| < CHAR : "char" >
| < DATE : "date" >
| < CREATE : "create" >
| < DROP : "drop" >
| < DESC : "desc" >
| < SHOW : "show" >
| < SELECT : "select" >
| < INSERT : "insert" >
| < DELETE : "delete" >
| < TABLE : "table" >
| < TABLES : "tables" >
| < INTO : "into" >
| < NOT : "not" >
| < NULL : "null" >
| < IS : "is" >
| < AS : "as" >
| < AND : "and" >
| < OR : "or" >
| < FROM : "from" >
| < WHERE : "where" >
| < VALUES : "values" >
| < PRIMARY : "primary" >
| < FOREIGN : "foreign" >
| < KEY : "key" >
| < REFERENCES : "references" >
}

TOKEN :
{
  < SEMICOLON : ";" >
| < LEFT_PAREN : "(" >
| < RIGHT_PAREN : ")" >
| < COMMA : "," >
| < PERIOD : "." >
| < UNDERSCORE : "_" >
| < QUOTE : "'" >
| < INT_VALUE : (< SIGN >)? (< DIGIT >)+>
| < DATE_VALUE : < NNNN > "-" < NN > "-" < NN > >
| < NNNN : < DIGIT > < DIGIT > < DIGIT > < DIGIT > >
| < NN : < DIGIT > < DIGIT > >
| < SIGN : "+" | "-" >
| < ASTERISK : "*" >
| < COMP_OP : "<" | ">" | "=" | ">=" | "<=" | "!=" >
| < DIGIT : [ "0"-"9" ] >
| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >
| < ALPHABET : [ "a"-"z", "A"-"Z" ] >
| < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER>)* < QUOTE > >
| < NON_QUOTE_SPECIAL_CHARACTER : ["!", "@", "#", "$", "%", "^", "&", "-",
    "{", "}", "[", "]", "~", "`", "+", "*", "_", "=", "\\", "(", ")", "<", ">",
    "?", ",", ".", "\n", "\t", "\r", ":", ";", "|", "/"] >
| < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET > | " " |
    < NON_QUOTE_SPECIAL_CHARACTER > >
}

void command() :
{}
{
  queryList()
| (
    < EXIT >
    < SEMICOLON >
    {
      System.exit(0);
    }
  ) 
}

void queryList() :
{
  QueryType type;
}
{
  (
    type = query()
    < SEMICOLON >
    {
      printMessage(type);
    }
  )+
}

QueryType query() :
{
  QueryType type;
}
{
  (
    type = createTableQuery()
  | type = dropTableQuery()
  | type = descTableQuery()
  | type = showTablesQuery()
  | type = selectQuery()
  | type = insertQuery()
  | type = deleteQuery()
  )
  {
    return type;
  }
}

QueryType createTableQuery() :
{}
{
  < CREATE > < TABLE >
  tableName()
  tableElementList()
  {
    return QueryType.CREATE_TABLE;
  }
}

QueryType dropTableQuery() :
{}
{
  < DROP > < TABLE >
  tableName()
  {
    return QueryType.DROP_TABLE;
  }
}

QueryType descTableQuery() :
{}
{
  < DESC >
  tableName()
  {
    return QueryType.DESC;
  }
}

QueryType showTablesQuery() :
{}
{
  < SHOW > < TABLES >
  {
    return QueryType.SHOW_TABLES;
  }
}

QueryType selectQuery() :
{}
{
  < SELECT >
  selectList()
  tableExpression()
  {
    return QueryType.SELECT;
  }
}

QueryType insertQuery() :
{}
{
  < INSERT > < INTO >
  tableName()
  insertColumnsAndSource()
  {
    return QueryType.INSERT;
  }
}

QueryType deleteQuery() :
{}
{
  < DELETE > < FROM >
  tableName()
  (
    whereClause()
  )+
  {
    return QueryType.DELETE;
  }
}

void tableElementList() :
{}
{
  < LEFT_PAREN >
  tableElement()
  (
    < COMMA >
    tableElement()
  )*
  < RIGHT_PAREN >
}

void tableElement() :
{
}
{
  columnDefinition()
| tableConstraintDefinition()
}

void columnDefinition() :
{}
{
  columnName()
  dataType()
  (
    < NOT > < NULL >
  )?
}

void tableConstraintDefinition() :
{}
{
  primaryKeyConstraint()
| referentialConstraint()
}

void primaryKeyConstraint() :
{}
{
  < PRIMARY > < KEY >
  columnNameList()
}

void referentialConstraint() :
{}
{
  < FOREIGN > < KEY >
  columnNameList()
  < REFERENCES >
  tableName()
  columnNameList()
}

void selectList() :
{}
{
  < ASTERISK >
| (
    selectedColumn()
    (
      < COMMA >
      selectedColumn()
    )*
  )
}

void selectedColumn() :
{}
{
  (
    // as both tableName() and columnName() can match <LEGAL_IDENTIFIER>,
    // we should look ahead 2 tokens for choice.
    LOOKAHEAD(2)
    tableName()
    < PERIOD >
  )?
  columnName()
  (
    < AS >
    columnName()
  )?
}

void insertColumnsAndSource() :
{}
{
  (
    columnNameList()
  )?
  valueList()
}

void valueList() :
{}
{
  < VALUES >
  < LEFT_PAREN >
  value()
  (
    < COMMA >
    value()
  )*
  < RIGHT_PAREN >
}

void tableExpression() :
{}
{
  fromClause()
  (
    whereClause()
  )?
}

void fromClause() :
{}
{
  < FROM >
  tableReferenceList()
}

void whereClause() :
{}
{
  < WHERE >
  booleanValueExpression()
}

void tableReferenceList() :
{}
{
  referedTable()
  (
    < COMMA >
    referedTable()
  )*
}

void referedTable() :
{}
{
  tableName()
  (
    < AS >
    tableName()
  )?
}

void columnNameList() :
{}
{
  < LEFT_PAREN >
  columnName()
  (
    < COMMA >
    columnName()
  )*
  < RIGHT_PAREN >
}

void booleanValueExpression() :
{}
{
  booleanTerm()
  (
    < OR >
    booleanTerm()
  )*
}

void booleanTerm() :
{}
{
  booleanFactor()
  (
    < AND >
    booleanFactor()
  )*
}

void booleanFactor() :
{}
{
  (< NOT >)?
  booleanTest()
}

void booleanTest() :
{}
{
  predicate()
| parenthesizedBooleanExpression()
}

void parenthesizedBooleanExpression() :
{}
{
  < LEFT_PAREN >
  booleanValueExpression()
  < RIGHT_PAREN >
}

void predicate() :
{}
{
  // as both tableName() and columnName() can match (<LEGAL_IDENTIFIER> <COMMA>
  // <LEGA_IDENTIFIER>), we should look ahead 4 tokens for choice.
  LOOKAHEAD(4)
  comparisionPredicate()
| nullPredicate()
}

void comparisionPredicate() :
{}
{
  compOperand()
  < COMP_OP >
  compOperand()
}

void nullPredicate() :
{}
{
  (
    // as both tableName() and columnName() can match <LEGAL_IDENTIFIER>,
    // we should look ahead 2 tokens for choice.
    LOOKAHEAD(2)
    tableName()
    < PERIOD >
  )?
  columnName()
  nullOperation()
}

void compOperand() :
{}
{
  comparableValue()
| (
    (
      // as both tableName() and columnName() can match <LEGAL_IDENTIFIER>,
      // we should look ahead 2 tokens for choice.
      LOOKAHEAD(2)
      tableName()
      < PERIOD >
    )?
    columnName()
  )
}

void value() :
{}
{
  < NULL >
| comparableValue()
}

void comparableValue() :
{}
{
  < INT_VALUE >
| < CHAR_STRING >
| < DATE_VALUE >
}

void nullOperation() :
{}
{
  < IS >
  (< NOT >)?
  < NULL >
}

void dataType() :
{}
{
  < INT >
| (
    < CHAR >
    < LEFT_PAREN >
    < INT_VALUE >
    < RIGHT_PAREN >
  )
| < DATE >
}

void tableName() :
{}
{
  < LEGAL_IDENTIFIER >
}

void columnName() :
{}
{
  < LEGAL_IDENTIFIER >
}